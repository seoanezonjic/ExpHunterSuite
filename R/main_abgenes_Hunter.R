#' Main Aberrant Expression function
#'
#' `main_abgenes_Hunter` runs DROP OUTRIDER analysis.
#' @param sample_annotation Path to sample annotation table. See documentation.
#' @param anno_database TxDb annotation database created by preprocess_gtf
#' function.
#' @param count_ranges Count ranges file generated by preprocess_gtf function.
#' @param gene_mapping_file Gene mapping file generated by preprocess_gtf
#' function.
#' @param count_files Count tables to process. Can be in rds or table format.
#' @param dataset Name of the dataset.
#' @param cpu Amount of CPUs available for analysis. Default 1.
#' @param fpkm_cutoff Min FPKM value for read filtering. Default 3.
#' @param implementation Method for sample covariation removal in OUTRIDER.
#' Possible values: "autoencoder" (default), "pca" or "peer".
#' @param max_dim_proportion Maximum value for autoencoder encoding
#' dimension. Default 3, optimum for aberrant expression.
#' @param hpo_file Genes and associated HPO terms table. Optional.
#' @param sample_bam_stats Bam stats of each sample.Generated with samtools
#' idxstats (see Aberrant_Expression workflow for how to generate this file).
#' @param top_N Top N genes by adjusted p-value to select for OUTRIDER
#' overview. Default 10.
#' @return Aberrant expression object containing all analysis results.
#' @importFrom data.table fread
#' @importFrom dplyr left_join
#' @importFrom BiocParallel register MulticoreParam bplapply
#' @importFrom utils write.table
#' @importFrom SummarizedExperiment SummarizedExperiment colData rowData
#' rowRanges mcols
#' @importFrom OUTRIDER OutriderDataSet filterExpression estimateSizeFactors
#' findEncodingDim OUTRIDER results plotEncDimSearch plotAberrantPerSample
#' plotCountCorHeatmap plotCountGeneSampleHeatmap
#' @importFrom AnnotationDbi loadDb
#' @importFrom yaml read_yaml
#' @importFrom S4Vectors endoapply
#' @importFrom ggplot2 labs scale_color_brewer aes geom_boxplot theme_bw
#' geom_point ylim geom_histogram scale_x_log10 facet_wrap guides guide_legend
#' theme element_rect
#' @importFrom cowplot theme_cowplot background_grid plot_grid
#' @importFrom MatrixGenerics rowQuantiles
#' @export

main_abgenes_Hunter <- function(
	sample_annotation = NULL,
	anno_database = NULL,
	count_ranges = NULL,
	gene_mapping_file = NULL,
	count_files = NULL,
	dataset = NULL,
	cpu = 1,
	fpkm_cutoff = 1,
	implementation = "autoencoder",
	max_dim_proportion = 3,
	hpo_file = NULL,
	sample_bam_stats = NULL,
	top_N = 10
  ){
  	save(list = ls(all.names = TRUE), file = "environment.RData")
  	sample_anno <- data.table::fread(sample_annotation,
  									colClasses = c(RNA_ID = 'character',
  												   DNA_ID = 'character'))
  	txdb <- AnnotationDbi::loadDb(anno_database)
  	counts <- merge_counts(cpu = cpu, sample_anno = sample_anno,
  						   count_files = count_files,
  						   count_ranges = count_ranges)

	ods_unfitted <- filter_counts(counts = counts,
								  txdb = txdb,
								  fpkm_cutoff = fpkm_cutoff)

	ods <- runOutrider(unfitted_ods = ods_unfitted, implementation = implementation,
				max_dim_proportion = max_dim_proportion)

	# ORIGIN: OUTRIDER_Results.R

	res <- OUTRIDER::results(ods,
				 padjCutoff = cfg$aberrantExpression$padjCutoff,
				 zScoreCutoff = cfg$aberrantExpression$zScoreCutoff, all = TRUE)

	# Add fold change
	res[, foldChange := round(2^l2fc, 2)] 

	# Save all the results and significant ones
	OUTRIDER_results_all <- res
	saveRDS(OUTRIDER_results_all, paste0(dataset,
									'_OUTRIDER_results_all.rds'))

	# Subset to significant results
	res <- res[padjust <= cfg$aberrantExpression$padjCutoff &
	               abs(zScore) > cfg$aberrantExpression$zScoreCutoff]

	gene_annot_dt <- data.table::fread(gene_mapping_file)
	if(!is.null(gene_annot_dt$gene_name)){
	  if(grepl('ENSG00', res[1,geneID]) & grepl('ENSG00', gene_annot_dt[1,gene_id])){
	    res <- merge(res, gene_annot_dt[, .(gene_id, gene_name)],
	                 by.x = 'geneID', by.y = 'gene_id', sort = FALSE, all.x = TRUE)
	    data.table::setnames(res, 'gene_name', 'hgncSymbol')
	    res <- cbind(res[, .(hgncSymbol)], res[, - 'hgncSymbol'])
	  }
	}
	sa <- data.table::fread(sample_annotation,
			colClasses = c(RNA_ID = 'character', DNA_ID = 'character'))
	if(!is.null(sa$HPO_TERMS) & nrow(res) > 0){
	  if(!all(is.na(sa$HPO_TERMS)) & ! all(sa$HPO_TERMS == '')){
	    res <- add_HPO_cols(res, hpo_file = hpo_file)
	  }
	}

	# Save results
	OUTRIDER_results_table <- res
	data.table::fwrite(OUTRIDER_results_table,
					   paste0(dataset, '_OUTRIDER_results.tsv'),
						      sep = "\t",quote = F) 

	# ORIGIN: OUTRIDER_Summary.R

	# used for most plots
	dataset_title <- paste("Dataset:", paste(dataset,
							names(cfg$geneAnnotation), sep = '--'))

	OUTRIDER::plotEncDimSearch(ods) +
	          ggplot2::labs(title = dataset_title) +
	          cowplot::theme_cowplot() +
	          cowplot::background_grid() +
	          ggplot2::scale_color_brewer(palette="Dark2")

	OUTRIDER::plotAberrantPerSample(ods, main = dataset_title, 
	                                padjCutoff = cfg$aberrantExpression$padjCutoff,
	                                zScoreCutoff = cfg$aberrantExpression$zScoreCutoff)

	OUTRIDER::plotCountCorHeatmap(ods, normalized = FALSE, colGroups = "EXTERNAL", colColSet = "Dark2",
	                              main = paste0('Raw Counts (', dataset_title, ')'))
	OUTRIDER::plotCountCorHeatmap(ods, normalized = TRUE, colGroups = "EXTERNAL", colColSet = "Dark2",
	                              main = paste0('Normalized Counts (', dataset_title, ')'))

	OUTRIDER::plotCountGeneSampleHeatmap(ods, normalized = FALSE, nGenes = 50, colGroups = "EXTERNAL", colColSet = "Dark2",
	                                     main = paste0('Raw Counts (', dataset_title, ')'),
	                                     bcvQuantile = .95, show_names = 'row')
	OUTRIDER::plotCountGeneSampleHeatmap(ods, normalized = TRUE, nGenes = 50, colGroups = "EXTERNAL", colColSet = "Dark2",
	                                     main = paste0('Normalized Counts (', dataset_title,')'),
	                                     bcvQuantile = .95, show_names = 'row')

	before <- data.table::data.table(when = "Before",
	                     BCV = 1/sqrt(estimateThetaWithoutAutoCorrect(ods)))
	after <- data.table::data.table(when = "After", BCV = 1/sqrt( theta( ods )))
	bcv_dt <- rbind(before, after)

	# boxplot of BCV Before and After Autoencoder
	ggplot2::ggplot(bcv_dt, ggplot2::aes(when, BCV)) +
	                ggplot2::geom_boxplot() +
	                ggplot2::theme_bw(base_size = 14) +
	                ggplot2::labs(x = "Autoencoder correction",
	                              y = "Biological coefficient \nof variation",
	                              title = dataset_title)

	res <- OUTRIDER_results_table # VenÃ­a de snakemake@input$results

	## This block looks more of a report than anything
	if (nrow(res) > 0) {
	  ab_table <- res[AberrantBySample > nrow(ods)/1000, .("Outlier genes" = .N), by = .(sampleID)] %>% unique
	  if (nrow(ab_table) > 0) {
	    data.table::setorder(ab_table, "Outlier genes") 
	    DT::datatable(ab_table)
	  } else {
	    print("no aberrant samples")
	  }
	} else {
	  print('no results')
	}

	# ORIGIN: mergeBamStats.R. Depends on bamStats, bash script.

	sa <- read.table(file = sample_annotation, sep = '\t', header = TRUE) # es un data frame
	bams_folder <- dirname(sample_bam_stats)
	bams <- list.files(bams_folder, pattern=".txt", full.names = TRUE)
	bam_coverage <- data.frame("sampleID" = rep(NA, length(bams)), "record_count" = NA)

	for (i in 1:length(bams)) {
	    bam_coverage[i,] <- read.table(bams[i])
	}

	bam_coverage$record_count <- as.numeric(bam_coverage$record_count)
	write.table(bam_coverage, file = paste0(dataset,"_outrider.tsv"), row.names = FALSE, sep = "\t")

	# ORIGIN: counting_Summary.R

	# Old, was useful when multiple bam_stats files were loaded. Leaving it here just in case.
	# bam_folder <- stringr::str_sub(bam_stats,1,-6)
	# bam_stats_files <- list.files(bam_folder, pattern=stringr::str_sub(bam_stats,-6,-1))
	# parsed_bam_stats <- sapply(bam_stats_files, function(x) paste0(bam_folder,x))

	has_external <- any(as.logical(SummarizedExperiment::colData(ods)$isExternal))
	cnts_mtx_local <- OUTRIDER::counts(ods, normalized = F)[, !as.logical(ods@colData$isExternal)]
	cnts_mtx <- OUTRIDER::counts(ods, normalized = F)

	rownames(bam_coverage) <- bam_coverage$sampleID
	coverage_df <- data.frame(sampleID = colnames(ods),
	                        read_count = colSums(cnts_mtx))
	coverage_df <- merge(bam_coverage, coverage_df, by = "sampleID", sort = FALSE)
	# read count
	coverage_dt <- data.table::data.table(coverage_df)
	data.table::setorder(coverage_dt, read_count)
	coverage_dt[, count_rank := .I]
	# ratio
	coverage_dt[, counted_frac := read_count/record_count]
	data.table::setorder(coverage_dt, counted_frac)
	coverage_dt[, frac_rank := .I]

	# size factors 
	ods <- OUTRIDER::estimateSizeFactors(ods)
	local_size_factors <- OUTRIDER::sizeFactors(ods)[names(OUTRIDER::sizeFactors(ods)) %in% rownames(bam_coverage)]
	coverage_dt[, size_factors := local_size_factors]
	data.table::setorder(coverage_dt, size_factors)
	coverage_dt[, sf_rank := 1:.N]

	### @alvaro This block introduces the concept of sample rank. It seems to be
	### the order by which the samples are sorted according to read counts,
	### read count ratio and size factors. Need to properly understand the concept
	### of size factor. Plots should be improved to include sample IDs.

	p_depth <- ggplot2::ggplot(coverage_dt, ggplot2::aes(x = count_rank, y = read_count)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = "Read Counts", x="Sample Rank", y = "Reads Counted") +
	ggplot2::ylim(c(0,NA)) +
	ggplot2::scale_color_brewer(palette="Dark2")

	p_frac <- ggplot2::ggplot(coverage_dt, ggplot2::aes(x = frac_rank, y = counted_frac)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = "Read Count Ratio", x = "Sample Rank", y = "Percent Reads Counted") +
	ggplot2::ylim(c(0,NA)) +
	ggplot2::scale_color_brewer(palette="Dark2")

	#+ QC, fig.height=6, fig.width=12
	cowplot::plot_grid(p_depth, p_frac) 

	p_sf <- ggplot2::ggplot(coverage_dt, ggplot2::aes(sf_rank, local_size_factors)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	ggplot2::ylim(c(0,NA)) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = 'Size Factors', x = 'Sample Rank', y = 'Size Factors') +
	ggplot2::scale_color_brewer(palette="Dark2")

	p_sf_cov <- ggplot2::ggplot(coverage_dt, ggplot2::aes(read_count, size_factors)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	ggplot2::ylim(c(0,NA)) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = 'Size Factors vs. Read Counts',
	     x = 'Reads Counted', y = 'Size Factors') +
	ggplot2::scale_color_brewer(palette="Dark2")

	cowplot::plot_grid(p_sf, p_sf_cov) 

	quant <- .95

	if(has_external){
	  filter_mtx <- list(
	    local = cnts_mtx_local,
	    all = cnts_mtx,
	    `passed FPKM` = cnts_mtx[SummarizedExperiment::rowData(ods)$passedFilter,],
	    `min 1 read` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 1, ],
	    `min 10 reads` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 10, ]
	  )
	  filter_dt <- lapply(names(filter_mtx), function(filter_name) {
	    mtx <- filter_mtx[[filter_name]]
	    data.table::data.table(gene_ID = rownames(mtx), median_counts = rowMeans(mtx), filter = filter_name)
	  }) %>% rbindlist
	  filter_dt[, filter := factor(filter, levels = c('local', 'all', 'passed FPKM', 'min 1 read', 'min 10 reads'))]
	} else {
	  filter_mtx <- list(
	    all = cnts_mtx,
	    `passed FPKM` = cnts_mtx[SummarizedExperiment::rowData(ods)$passedFilter,],
	    `min 1 read` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 1, ],
	    `min 10 reads` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 10, ]
	  )
	  filter_dt <- lapply(names(filter_mtx), function(filter_name) {
	    mtx <- filter_mtx[[filter_name]]
	    data.table::data.table(gene_ID = rownames(mtx), median_counts = rowMeans(mtx), filter = filter_name)
	  }) %>% rbindlist
	  filter_dt[, filter := factor(filter, levels = c('all', 'passed FPKM', 'min 1 read', 'min 10 reads'))]
	}

	binwidth <- .2
	p_hist <- ggplot2::ggplot(filter_dt, ggplot2::aes(x = median_counts, fill = filter)) +
	ggplot2::geom_histogram(binwidth = binwidth) +
	ggplot2::scale_x_log10() +
	ggplot2::facet_wrap(.~filter) +
	ggplot2::labs(x = "Mean counts per gene", y = "Frequency", title = 'Mean Count Distribution') +
	ggplot2::guides(col = ggplot2::guide_legend(title = NULL)) +
	ggplot2::scale_fill_brewer(palette = "Paired") +
	cowplot::theme_cowplot() +
	ggplot2::theme(legend.position = "none")

	p_dens <- ggplot2::ggplot(filter_dt, ggplot2::aes(x = median_counts, col = filter)) +
	ggplot2::geom_density(ggplot2::aes(y=binwidth * ..count..), size = 1.2) +
	ggplot2::scale_x_log10() +
	ggplot2::labs(x = "Mean counts per gene", y = "Frequency") +
	ggplot2::guides(col = ggplot2::guide_legend(title = NULL)) +
	ggplot2::scale_color_brewer(palette = "Paired") +
	cowplot::theme_cowplot() +
	ggplot2::theme(legend.position = "top",
	      legend.justification="center",
	      legend.background = ggplot2::element_rect(color = NA))

	cowplot::plot_grid(p_hist, p_dens)

	exp_genes_cols <- c(Rank = "expressedGenesRank",`Expressed\ngenes` = "expressedGenes", 
	                  `Union of\nexpressed genes` = "unionExpressedGenes", 
	                  `Intersection of\nexpressed genes` = "intersectionExpressedGenes", 
	                  `Genes passed\nfiltering` = "passedFilterGenes")

	expressed_genes <- data.table::as.data.table(SummarizedExperiment::colData(ods)[, exp_genes_cols])
	colnames(expressed_genes) <- names(exp_genes_cols)

	#+ expressedGenes, fig.height=6, fig.width=8
	OUTRIDER::plotExpressedGenes(ods) + 
	cowplot::theme_cowplot() +
	cowplot::background_grid(major = "y") +
	ggplot2::geom_point(data = data.table::melt(expressed_genes, id.vars = c("Rank")),
	           ggplot2::aes(x = Rank, y = value, col = variable), show.legend = has_external)

	if(has_external){
	  DT::datatable(expressed_genes[order(Rank)], rownames = F)
	} else{
	  DT::datatable(expressed_genes[order(Rank), -"Is External"], rownames = F)
	}

	write.table(expressed_genes, paste0(dataset, "_expressed_genes.tsv"), sep="\t", row.names= F)

	# ORIGIN: OUTRIDER_Overview.R

	sortedRes <- OUTRIDER_results_table[order(OUTRIDER_results_table$padj_rank), ]
	sigSamples <- unique(sortedRes$sampleID)
	sigGenes <- head(unique(sortedRes$geneID), top_N)

	if(length(sigSamples > 1)) {
		BiocParallel::bplapply(sigSamples, AE_Sample_Overview, ods = ods,
							   dataset = dataset, cfg = cfg)
	}
	
	if(length(sigGenes > 1)) {
		BiocParallel::bplapply(sigGenes, AE_Gene_Overview, ods = ods,
							   dataset = dataset, cfg = cfg)
	}

	# ORIGIN: format_for_report.R, custom script

	data <- processed_vs_imported(OUTRIDER_results_all)
	aberrants <- lapply(data, get_aberrants,
		zScoreCutoff = cfg$aberrantExpression$zScoreCutoff,
		padjCutoff = cfg$aberrantExpression$padjCutoff)
	formatted <- lapply(aberrants, format_aberrants)

	write.table(formatted$processed, "processed_AE_results.tsv", quote = FALSE, row.names = FALSE)
	write.table(formatted$imported, "imported_AE_results.tsv", quote = FALSE, row.names = FALSE)

	final_results <- list()
	final_results$counts <- counts
	final_results$ods_unfitted <- ods_unfitted
	final_results$ods <- ods
	final_results$OUTRIDER_results_all <- OUTRIDER_results_all
	final_results$OUTRIDER_results_table <- OUTRIDER_results_table
	final_results$bam_coverage <- bam_coverage
	final_results$formatted <- formatted
	return(final_results)

}
