#' Main Aberrant Expression function
#'
#' `main_abgenes_Hunter` runs DROP OUTRIDER analysis.
#' @param sample_annotation Path to sample annotation table. See documentation.
#' @param anno_database TxDb annotation database created by preprocess_gtf
#' function.
#' @param count_ranges Count ranges file generated by preprocess_gtf function.
#' @param gene_mapping_file Gene mapping file generated by preprocess_gtf
#' function.
#' @param count_files Count tables to process. Can be in rds or table format.
#' @param dataset Name of the dataset.
#' @param cpu Amount of CPUs available for analysis. Default 1.
#' @param fpkm_cutoff Min FPKM value for read filtering. Default 3.
#' @param implementation Method for sample covariation removal in OUTRIDER.
#' Possible values: "autoencoder" (default), "pca" or "peer".
#' @param z_score_cutoff Cutoff that gene zScore must surpass in order to be
#' considered aberrantly expressed.
#' @param p_adj_cutoff Adjusted p-value cutoff. Gene adjusted p-value must be
#' lower than this number in order to be considered aberrantly expressed.
#' @param max_dim_proportion Maximum value for autoencoder encoding
#' dimension. Default 3, optimum for aberrant expression.
#' @param hpo_file File containing HPO terms associated to genes. Optional.
#' @param stats_path Bam stats directories of each sample. Stats generated
#' with samtools idxstats (see Aberrant_Expression workflow for how to generate
#' this file).
#' @param top_N Top N genes by adjusted p-value to select for OUTRIDER
#' overview. Default 10.
#' @return Aberrant expression object containing all analysis results.
#' @importFrom data.table fread
#' @importFrom dplyr left_join
#' @importFrom BiocParallel register MulticoreParam bplapply
#' @importFrom utils write.table
#' @importFrom SummarizedExperiment SummarizedExperiment colData rowData
#' rowRanges mcols
#' @importFrom OUTRIDER OutriderDataSet filterExpression estimateSizeFactors
#' findEncodingDim OUTRIDER results plotEncDimSearch plotAberrantPerSample
#' plotCountCorHeatmap plotCountGeneSampleHeatmap
#' @importFrom AnnotationDbi loadDb
#' @importFrom S4Vectors endoapply
#' @importFrom ggplot2 labs scale_color_brewer aes geom_boxplot theme_bw
#' geom_point ylim geom_histogram scale_x_log10 facet_wrap guides guide_legend
#' theme element_rect
#' @importFrom cowplot theme_cowplot background_grid plot_grid
#' @importFrom MatrixGenerics rowQuantiles
#' @export

main_abgenes_Hunter <- function(sample_annotation = NULL, anno_database = NULL,
								count_ranges = NULL, gene_mapping_file = NULL,
								count_files = NULL, dataset = NULL, cpu = 1,
								fpkm_cutoff = 1, implementation = "autoencoder",
								max_dim_proportion = 3, p_adj_cutoff = 0.05,
								z_score_cutoff = 0.2, hpo_file = NULL,
								stats_path = NULL, top_N = 10) {
  	sample_anno <- data.table::fread(sample_annotation,
  									colClasses = c(RNA_ID = 'character',
  												   DNA_ID = 'character'))
  	txdb <- AnnotationDbi::loadDb(anno_database)
  	counts <- merge_counts(cpu = cpu, sample_anno = sample_anno,
  						   count_files = count_files,
  						   count_ranges = count_ranges)
	ods_unfitted <- filter_counts(counts = counts, txdb = txdb,
								  fpkm_cutoff = fpkm_cutoff)
	ods <- run_outrider(ods_unfitted = ods_unfitted,
						implementation = implementation,
						max_dim_proportion = max_dim_proportion)
	outrider_results <- get_ods_results(ods = ods, p_adj_cutoff = p_adj_cutoff,
										z_score_cutoff = z_score_cutoff,
										gene_mapping_file = gene_mapping_file,
										sample_anno = sample_anno)
	bcv_dt <- get_bcv(ods)
	bam_coverage <- merge_bam_stats(stats_path = stats_path)
	save(list = ls(all.names = TRUE), file = "environment.RData")
	formatted <- format_for_report(outrider_results$all,
								   z_score_cutoff, p_adj_cutoff)
	final_results <- list()
	final_results$counts <- counts
	final_results$ods_unfitted <- ods_unfitted
	final_results$ods <- ods
	final_results$outrider_res_all <- outrider_results$all
	final_results$outrider_res_table <- outrider_results$table
	final_results$bam_coverage <- bam_coverage
	final_results$formatted <- formatted
	final_results$bcv_dt <- bcv_dt
	return(final_results)
}

### plotting_things

placeholder <- function(juas) {

	# THIS PART HAS ALREADY MIGRATED, THERE ARE FUNCTIONS IN
	# main_degenes_Hunter.R that already do this.
	has_external <- any(as.logical(SummarizedExperiment::colData(ods)$isExternal))
	cnts_mtx_local <- OUTRIDER::counts(ods, normalized = F)[, !as.logical(ods@colData$isExternal)]
	cnts_mtx <- OUTRIDER::counts(ods, normalized = F)

	rownames(bam_coverage) <- bam_coverage$sampleID
	coverage_df <- data.frame(sampleID = colnames(ods),
	                          read_count = colSums(cnts_mtx))
	coverage_df <- merge(bam_coverage, coverage_df, by = "sampleID", sort = FALSE)
	# read count
	coverage_dt <- data.table::data.table(coverage_df)
	data.table::setorder(coverage_dt, read_count)
	coverage_dt[, count_rank := .I]
	# ratio
	coverage_dt[, counted_frac := read_count/record_count]
	data.table::setorder(coverage_dt, counted_frac)
	coverage_dt[, frac_rank := .I]

	# size factors 
	ods <- OUTRIDER::estimateSizeFactors(ods)
	local_size_factors <- OUTRIDER::sizeFactors(ods)[names(OUTRIDER::sizeFactors(ods)) %in% rownames(bam_coverage)]
	coverage_dt[, size_factors := local_size_factors]
	data.table::setorder(coverage_dt, size_factors)
	coverage_dt[, sf_rank := 1:.N]

	p_depth <- ggplot2::ggplot(coverage_dt, ggplot2::aes(x = count_rank, y = read_count)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = "Read Counts", x="Sample Rank", y = "Reads Counted") +
	ggplot2::ylim(c(0,NA)) +
	ggplot2::scale_color_brewer(palette="Dark2")

	p_frac <- ggplot2::ggplot(coverage_dt, ggplot2::aes(x = frac_rank, y = counted_frac)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = "Read Count Ratio", x = "Sample Rank", y = "Percent Reads Counted") +
	ggplot2::ylim(c(0,NA)) +
	ggplot2::scale_color_brewer(palette="Dark2")

	#+ QC, fig.height=6, fig.width=12
	cowplot::plot_grid(p_depth, p_frac) 

	p_sf <- ggplot2::ggplot(coverage_dt, ggplot2::aes(sf_rank, local_size_factors)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	ggplot2::ylim(c(0,NA)) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = 'Size Factors', x = 'Sample Rank', y = 'Size Factors') +
	ggplot2::scale_color_brewer(palette="Dark2")

	p_sf_cov <- ggplot2::ggplot(coverage_dt, ggplot2::aes(read_count, size_factors)) +
	ggplot2::geom_point(size = 3, show.legend = has_external) +
	ggplot2::ylim(c(0,NA)) +
	cowplot::theme_cowplot() +
	cowplot::background_grid() +
	ggplot2::labs(title = 'Size Factors vs. Read Counts',
	     x = 'Reads Counted', y = 'Size Factors') +
	ggplot2::scale_color_brewer(palette="Dark2")

	cowplot::plot_grid(p_sf, p_sf_cov)
	### @alvaro This block introduces the concept of sample rank. It seems to be
	### the order by which the samples are sorted according to read counts,
	### read count ratio and size factors. Need to properly understand the concept
	### of size factor. Plots should be improved to include sample IDs.

	quant <- .95

	if(has_external){
	  filter_mtx <- list(
	    local = cnts_mtx_local,
	    all = cnts_mtx,
	    `passed FPKM` = cnts_mtx[SummarizedExperiment::rowData(ods)$passedFilter,],
	    `min 1 read` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 1, ],
	    `min 10 reads` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 10, ]
	  )
	  filter_dt <- lapply(names(filter_mtx), function(filter_name) {
	    mtx <- filter_mtx[[filter_name]]
	    data.table::data.table(gene_ID = rownames(mtx), median_counts = rowMeans(mtx), filter = filter_name)
	  }) %>% rbindlist
	  filter_dt[, filter := factor(filter, levels = c('local', 'all', 'passed FPKM', 'min 1 read', 'min 10 reads'))]
	} else {
	  filter_mtx <- list(
	    all = cnts_mtx,
	    `passed FPKM` = cnts_mtx[SummarizedExperiment::rowData(ods)$passedFilter,],
	    `min 1 read` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 1, ],
	    `min 10 reads` = cnts_mtx[MatrixGenerics::rowQuantiles(cnts_mtx, probs = quant) > 10, ]
	  )
	  filter_dt <- lapply(names(filter_mtx), function(filter_name) {
	    mtx <- filter_mtx[[filter_name]]
	    data.table::data.table(gene_ID = rownames(mtx), median_counts = rowMeans(mtx), filter = filter_name)
	  }) |> rbindlist()
	  filter_dt[, filter := factor(filter, levels = c('all', 'passed FPKM', 'min 1 read', 'min 10 reads'))]
	}

	binwidth <- .2
	p_hist <- ggplot2::ggplot(filter_dt, ggplot2::aes(x = median_counts, fill = filter)) +
	ggplot2::geom_histogram(binwidth = binwidth) +
	ggplot2::scale_x_log10() +
	ggplot2::facet_wrap(.~filter) +
	ggplot2::labs(x = "Mean counts per gene", y = "Frequency", title = 'Mean Count Distribution') +
	ggplot2::guides(col = ggplot2::guide_legend(title = NULL)) +
	ggplot2::scale_fill_brewer(palette = "Paired") +
	cowplot::theme_cowplot() +
	ggplot2::theme(legend.position = "none")

	p_dens <- ggplot2::ggplot(filter_dt, ggplot2::aes(x = median_counts, col = filter)) +
	ggplot2::geom_density(ggplot2::aes(y=binwidth * ..count..), size = 1.2) +
	ggplot2::scale_x_log10() +
	ggplot2::labs(x = "Mean counts per gene", y = "Frequency") +
	ggplot2::guides(col = ggplot2::guide_legend(title = NULL)) +
	ggplot2::scale_color_brewer(palette = "Paired") +
	cowplot::theme_cowplot() +
	ggplot2::theme(legend.position = "top",
	      legend.justification="center",
	      legend.background = ggplot2::element_rect(color = NA))

	cowplot::plot_grid(p_hist, p_dens)

	exp_genes_cols <- c(Rank = "expressedGenesRank",`Expressed\ngenes` = "expressedGenes", 
	                  `Union of\nexpressed genes` = "unionExpressedGenes", 
	                  `Intersection of\nexpressed genes` = "intersectionExpressedGenes", 
	                  `Genes passed\nfiltering` = "passedFilterGenes")

	expressed_genes <- data.table::as.data.table(SummarizedExperiment::colData(ods)[, exp_genes_cols])
	colnames(expressed_genes) <- names(exp_genes_cols)

	#+ expressedGenes, fig.height=6, fig.width=8
	OUTRIDER::plotExpressedGenes(ods) + 
	cowplot::theme_cowplot() +
	cowplot::background_grid(major = "y") +
	ggplot2::geom_point(data = data.table::melt(expressed_genes, id.vars = c("Rank")),
	           ggplot2::aes(x = Rank, y = value, col = variable), show.legend = has_external)

	if(has_external){
	  DT::datatable(expressed_genes[order(Rank)], rownames = F)
	} else{
	  DT::datatable(expressed_genes[order(Rank), -"Is External"], rownames = F)
	}
	sortedRes <- OUTRIDER_results_table[order(OUTRIDER_results_table$padj_rank), ]
	sigSamples <- unique(sortedRes$sampleID)
	sigGenes <- head(unique(sortedRes$geneID), top_N)

	if(length(sigSamples > 1)) {
		BiocParallel::bplapply(sigSamples, AE_Sample_Overview, ods = ods,
							   dataset = dataset, cfg = cfg)
	}
	
	if(length(sigGenes > 1)) {
		BiocParallel::bplapply(sigGenes, AE_Gene_Overview, ods = ods,
							   dataset = dataset, cfg = cfg)
	}
}

write_abgenes_results <- function(final_results, output_dir) {
	return("WIP")
}

write_abgenes_report <- function(final_results, output_dir = getwd(),
							 template_folder = NULL, source_folder = "none",
							 p_adj_cutoff = 0.05, z_score_cutoff = 3){
	if(is.null(template_folder)) {
		stop("No template folder was provided.")
	}
	if(!file.exists(source_folder)) {
		stop(paste0("Source folder not found. Was ", source_folder))
	}
	if(any(is.null(final_results))) {
		stop("ERROR: final_results object contains NULL fields. Analysis
			 is not complete.")
	}
	template <- file.path(template_folder, "abgenes_template.txt")
	tmp_folder <- "tmp_lib"
	out_file <- paste0(output_dir, "/abgenes_report.html")
	container <- list(counts = final_results$counts,
					  ods = final_results$ods,
					  ods_unfitted = final_results$ods_unfitted,
					  outrider_res_all = final_results$outrider_res_all,
					  outrider_res_table = final_results$outrider_res_table,
					  bam_coverage = final_results$bam_coverage,
					  formatted = final_results$formatted,
					  bcv_dt = final_results$bcv_dt,
					  p_adj_cutoff = p_adj_cutoff,
					  z_score_cutoff = z_score_cutoff)
	plotter <- htmlReport$new(title_doc = "Aberrant Expression report", 
					      	  container = container, 
	                      	  tmp_folder = tmp_folder,
	                      	  src = source_folder)
	plotter$build(template)
	plotter$write_report(out_file)
}
